% Body of report - this should include a requirement analysis and specification of the problem you have tackled.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      JUSTIFY ALL MY CHOICES                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newcommand{\objective}[1]{
	\subsubsection{#1}
}
\chapter{Specifications and Requirement Analysis (2074/2000)}
\section{Overview}
In order to investigate music similarity measure and its use in interpolative playlist generation, it is important to write a proof-of-concept piece of software which is capable of performing these functions, to show that the concepts discussed and the method proposed and designed are solid. A detailed specification of system behaviour has been designed in order to focus the development of this system; as stated in \citet{Bourque2004}, ``The Software Requirements Knowledge Area (KA) is concerned with the elicitation, analysis, specification, and validation of software requirements. It is widely acknowledged within the software industry that software engineering projects are critically vulnerable when these activities are performed poorly''. By specifying what is required of the software, and the requirements of the software itself, it becomes easier to design a system based around those goals and hence have a more succinct design and implementation. Additionally, later comparing the final system back to these specifications allows for critiquing of the system in terms of how well it met its goals and  assessing the viability of the system (or a future system based on the technique) for development into an end-user application.
\section{System Objectives}
\subsection{Research Requirements}
\note{Why did I set out an objective in the intro?!}
As the system is merely a proof-of-concept version of the similarity measure and playlist generation technique discussed in this paper, it is important that the system lend itself to extensive testing, and be easily extensible and adaptable should operation of any component need to be changed. The following are a set of requirements of the software for research: 
\objective{Provide a method to verify and view results at each step of the processing}
Verification and the ability to view input and output data of the system is important during the development process in order to ensure the correct operation of the code, and to track down any bugs which may arise. Tracking data flow through each step of the system can help to show any areas which may be operating incorrectly or suboptimally.

To achieve this, the system will be designed so that it is easy to debug, as well as providing a tool to view any binary files which may be stored. Also, where necessary, program options will be created which will reveal more detailed output about the operation of the system for testing and debugging purposes.
\objective{Provide a simple method to analyse music and create playlists in batch for testing}
% reading compressed files
As a large amount of audio files will need to be processed (the user's media library), and a lot of playlists generated for testing and debugging, it is important to have an interface to the program which allows for this. A command-line interface has been chosen, with the mode of operation and the files to process specified on the command-line and all output printed to the standard output and error streams. This simplifies the code needed to process options, and allows for batch scripts to be created which can automate testing. Also, operating without a GUI eases debugging of the system, which is important for the above requirement.
\objective{Allow components to be added and modified without (severely) affecting the operation of others}
% Encapsulation / Abstraction
Separating the concerns of similarity measure (audio processing and analysis) and playlist generation (statistical analysis) into separate programs means that the code itself will be simpler and clearer, which in turn means that it is easier to understand, develop, and test. As the algorithm for the similarity metric and playlist generation will be modified frequently during the development of the system, it is important that the two do not depend on each other more than necessary. Following the Object-Oriented design philosophy and its ideas of abstraction and encapsulation, the software will be written in \software{C++}, and the program logic seperated into classes, each dealing only with their own data and processing.
\subsection{User Requirements}
In addition to the development and research requirements, it is important to consider the needs of the hypothetical end-user, who would use a system based upon the technique later discussed. By setting out the requirements for a viable playlist generating application, the system and technique can be designed around this. The following are a set of base-line requirements for a feasible playlist generation system.
\objective{Analyse the user's media library in a reasonable time-frame}
Digital signal processing and audio analysis such as required by any audio-based similarity measure requires a great deal of data processing --- audio must be read from disk byte-by-byte and calculations performed based on this --- if a typical song (uncompressed) is 20MB, this translates to 5,242,880 floating-point additions and a division just to calculate the mean value! As the processing done on each song is immense, it is important to have this processing run as quick as possible, and avoid the need to re-process any one song.

To achieve the kind of speed needed, \software{C++} is a good choice of language as it is a very low-overhead, high speed language. As the amount of calculation required is unavoidable, the need to re-calculate data for a file will be avoided by storing the analysed data along with the audio files themselves; this means that if files are moved, the analysis data is moved with them.
\objective{Avoid storing too much data}
\label{text:spec:requirement:data}
If too much data for each song is stored it affects the scalability of the application, as for large media libraries the analysis data itself will take up a large amount of disk space. Additionally, the more data stored, the more calculation needed to compute similarity, increasing the time taken to generate playlists exponentially.
\objective{Provide a simpler method of playlist generation than selecting individual tracks}
Playlist interpolation easier to select yadda yadda 
\objective{Base playlist generation solely on analysis of audio data}
relate to problems with other software found in review
\note{add something about generating playlists quickly --- being slow at analysis is fine though}
\subsection{Extensions}
\objective{Provide a GUI for ease of use}
\objective{Provide a version which can run on portable devices (MP3 players, etc.)}
% The system which I have designed and created is a small demonstration system, tailored for ease and speed of development as development time is limited, verifiability of results to ensure correct operation of the system, and ease of testing outputs to assess the overall performance of the system.
\section{Requirement Analysis}
In addition to analysing what is required of the system, it is important to look at what will be required by the system itself. After looking at the requirements and functionality set out above, a list of software requirements of the system has been set out.
\subsection{Operating System}
Quick note about writing for Linux as it's easier? Code kept very portable, relying on libraries helps this.
\subsection{Software Libraries}
Throughout the development of the system, extensive use of software libraries has been made where possible to speed development time and reduce errors. As there are many software libraries available to aid in any individual task, several options have been evalutaed and reasons given for each choice.
\subsubsection{Audio Decoding}
Digital audio, when converted to analog for playback or processed in some way is read as a continuous stream of floating-point numbers between 1 and -1, representing the current level of the waveform. When stored on disk, however, there are hundreds of file formats, each with a different set of features and an entirely different algorithm for obtaining the floating-point numbers needed for processing. In a typical user's media library, there can be audio of very different types: MP3 for portable devices, AAC on Apple machines, WMA on Windows, FLAC for lossless compression, WAV for uncompressed audio; it is important that any signal analysis system is able to process at least these types in order to be usable. For the purposes of this proof-of-concept code, I began by using \software{libsndfile}[REF], which can read uncompressed audio files (such as WAV and AIFF). While this was suitable for development work, it quickly became evident that if a large number of audio files were to be processed, the system would need to be able to decode compressed audio (mainly MP3 and FLAC in my test corpus). Due to this,  the \software{GStreamer} multimedia framework has been used to decompress, downsample and mix audio to mono (\codepageref{SoundFile.cc}{21}) into a temporary WAV file, ready to be read in by libsndfile (\coderef{SoundFile.cc}{29}). While this provides a simple solution to the problem, it is not optimal as it induces the large overhead of spawning another process and writing to a temporary file; again a trade-off with development time and optimality, reading from the major formats could be directly implemented using their individual libraries, gaining processing speed and reducing overhead.
\subsubsection{Audio Analysis / DSP}
For the audio analysis section of the system, it was possible to use a number of software libraries to implement the signal processing and analysis. \software{Marsays}[REF], \software{MAAATE}[REF] and \software{libaudiofeat}[REF] are three libraries which allow the developer to pass in audio data and receive analysis data. Although this would have avoided the need to directly implement feature extractors (discussed later), it would mean sacrificing both speed in unneeded calculations (\software{libaudiofeat}) and flexibility in the feature extractors (\software{Marsyas} and \software{MAAATE}) which could be used. Also, as these were large and complex libraries, it would have taken as long to learn how to use the library as it would write to the code myself; due to this, the feature extractors were manually implemented and tested.
The feature extraction process required the computation of a Fourier Transform. As this is a complex mathematical procedure, the  \software{FFTW3} library has been used to perform the computation, as it is a highly optimised library specifically for doing Fourier Transforms.
\subsubsection{User Interface}
As discussed previously, a command-line interface has been implemented. In order to parse the options specified on the command-line, and provide a unified interface to the user, the \software{libpopt} library has been used to parse command-line options. Although this could have been implemented manually, much of the code of libpopt would need to be duplicated and would provide no real benefit.
\begin{comment}
	\begin{itemize}
		\item Give background on libraries used and what they are used for
		\item Give alternatives to some libraries and explain why they weren't used (Marsyas and MAAATE)
		\begin{itemize}
			\item lack of knowledge of libraries - would have taken as long to learn it as to have written it myself
			\item too big to leverage into the proof-of-concept example needed
			\item wouldn't allow as much flexibility in operation of the program
			\item this way is easier to modify in future to add more extractors / build on in any way
			\item why they would have been good
			\begin{itemize}
				\item easier to chop and change between features (not important for my project)
				\item ?
			\end{itemize}
		\end{itemize}
		\item GStreamer (vs. libmad, libogg/vorbis, libflac; directsound)
		\item libsndfile
		\item FFTW3 (vs. hand coded - OMG)
		\item libpopt (vs. hand coded - just lazy)
	\end{itemize}
\end{comment}
\subsection{Hardware \& Storage}
\begin{itemize}
	\item Hardware
	\begin{itemize}
		\item Fast processor
		\item Lots of HDD space for music itself, not much on top of that
	\end{itemize}
	\item Storage
	\begin{itemize}
		\item Seperate files easier to code \& debug
		\item Database slightly less reliable (moved files need to be recalculated) but much faster \& tidier
		\item Data stored on each track needs to be small so as not to take too much disk space
	\end{itemize}
\end{itemize}
% It should also include a description of how you have designed, built and evaluated your system.
% The exact form of this will vary from project to project but it will usually occupy several chapters
% and will often include sections on implementation and testing. Any software projects should included a 
% discussion of the principles which underlie the program which has been written: the significance of its data
% structures, the way that its procedures and modules interact etc.
\input{spec/professional_considerations}
