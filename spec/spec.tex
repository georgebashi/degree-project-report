% Body of report - this should include a requirement analysis and specification of the problem you have tackled.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      JUSTIFY ALL MY CHOICES                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newcommand{\objective}[1]{\begin{itemize}
	\item \textbf{#1}
\end{itemize}}
\chapter{Specifications and Requirement Analysis (2000)}
\section{Overview}
% set out what my software has to do
In order to investigate music similarity measure and its use in interpolative playlist generation, it is important for me to write a proof-of-concept piece of software which is capable of performing these functions, to show that the concepts discussed and my method proposed and designed are solid.
\note{Why specify system behaviour}
I have created a detailed specification of system behaviour in order to focus the development of this system. As stated in \citet{Bourque2004}, ``The Software Requirements Knowledge Area (KA) is concerned with the elicitation, analysis, specification, and validation of software requirements. It is widely acknowledged within the software industry that software engineering projects are critically vulnerable when these activities are performed poorly''. By specifying what is required of the software, and the requirements of the software itself, it becomes easier to design a system based around those goals, and hence have a more succinct design and implementation. Additionally, later comparing the final system back to these specifications allows me to both critique the system in terms of how well it met its goals, but also assess the viability of the system (or a future system based on the technique) for development into an end-user application.
\section{System Objectives}
\subsection{Research Requirements}
As the system is merely a proof-of-concept version of the similarity measure and playlist generation technique discussed in this paper, it is important that the system lend itself to extensive testing, and be easily extensible and adaptable, should I need to change the operation of any component. The following are a set of requirements of the software for research: 
\objective{Provide a method to verify and view results at each step of the processing}
Verification and the ability to view input and output data of the system is important during the development process in order to ensure the correct operation of the code, and to track down any bugs which may arise. Tracking data flow through each step of the system can help to show any areas which may be operating incorrectly or suboptimally.

To achieve this, I will design the system so that it is easy to debug, as well as providing a tool to view any binary files which may be stored. Also, where necessary, I will create program options which will reveal more detailed output about the operation of the system for testing and debugging purposes.
\objective{Provide a simple method to analyse music and create playlists in batch for testing}
% reading compressed files
As I will need to process a large amount of audio files (the user's media library), and generate lots of playlists for testing and debugging, it is important to have an interface to the program which allows for this. I have chosen to use a command-line interface, with the mode of operation and the files to process specified on the command-line, and all output printed to the standard output and error streams. This simplifies the code needed to process options, and allows me to create batch scripts which can automate testing. Also, operating without a GUI eases debugging of the system, which is important for the above requirement.
\objective{Allow components to be added and modified without (severely) affecting the operation of others}
% Encapsulation / Abstraction
Seperating the concerns of similarity measure (audio processing and analysis) and playlist generation (statistical analysis) into seperate programs means that the code itself will be simpler and clearer, which in turn means that it is easier to understand, develop, and test. As I will be modifying the algorithm with which the similarity measure and playlist generation works, it is important that the two do not depend on each other more than necessary. Following the Object-Oriented design philiosophy, and it's ideas of abstraction and encapsulation, I have written the software in C++, and seperated the program logic into seperate classes, each dealing only with their own data and processing.
\objective{Something else?}
\subsection{User Requirements}
In addition to the requirements for me as the developer and researcher, it is important to consider the needs of the hypothetical end-user, who would use a system based upon the technique later discussed. By setting out the requirements for a viable playlist generating application, I can design my system and technique around this. The following are a set of base-line requirements for a feasable playlist generation system.
\objective{Analyse the user's media library in a reasonable time-frame}
Digital signal processing and audio analysis such as required by any audio-based similarity measure requires a great deal of data processing - audio must be read from disk byte-by-byte and calculations performed based on this - if a typical song (uncompressed) is 20MB, this translates to 5,242,880 floating-point additions and a division just to calculate the mean value! As the processing done on each song is immense, it is important to have this processing run as quick as possible, and avoid the need to re-process any one song.

To achieve the kind of speed needed, C++ is a good choice of language as it is known to be one of the fastest programming languages. 
\objective{Avoid storing too much data}
Slow, uses lots of disk space etc.
\objective{Provide a simpler method of playlist generation than selecting individual tracks}
\objective{Base playlist generation solely on analysis of audio data}
relate to problems found in review
\subsection{Extensions}
\begin{itemize}
	\item Provide GUI
	\item Run on portable devices
\end{itemize}
What my system has to achieve for the purposes of this project, discussion of research questions
\note{Relate back to software review}
User requirements
% The system which I have designed and created is a small demonstration system, tailored for ease and speed of development as development time is limited, verifiability of results to ensure correct operation of the system, and ease of testing outputs to assess the overall performance of the system.
\section{Requirement Analysis}
By looking at the core functionality of the application itself,
I can set out more specific requirements about the software.
\subsection{Software \& Library Requirements}
\begin{itemize}
	\item Give background on libraries used and what they are used for
	\item Give alternatives to some libraries and explain why they wern't used (Marsyas and MAAATE)
	\begin{itemize}
		\item lack of knowledge of libraries - would have taken as long to learn it as to have written it myself
		\item too big to leverage into the proof-of-concept example needed
		\item wouldn't allow as much flexibility in operation of the program
		\item this way is easier to modify in future to add more extractors / build on in any way
		\item why they would have been good
		\begin{itemize}
			\item easier to chop and change between features (not important for my project)
			\item ?
		\end{itemize}
	\end{itemize}
	\item GStreamer (vs. libmad, libogg/vorbis, libflac; directsound)
	\item libsndfile
	\item FFTW3 (vs. hand coded - OMG)
	\item libpopt (vs. hand coded - just lazy)
\end{itemize}
\subsection{Usability Requirements}
\begin{itemize}
	\item Interface
	\begin{itemize}
		\item commandline as its simplest to write
		\item guis can easily be written to use the commandline tools in the background
	\end{itemize}
	\item Storage
	\begin{itemize}
		\item Seperate files easier to code \& debug
		\item Database slightly less reliable (moved files need to be recalculated) but much faster \& tidier
		\item Data stored on each track needs to be small so as not to take too much disk space
	\end{itemize}
\end{itemize}
% It should also include a description of how you have designed, built and evaluated your system.
% The exact form of this will vary from project to project but it will usually occupy several chapters
% and will often include sections on implementation and testing. Any software projects should included a 
% discussion of the principles which underlie the program which has been written: the significance of its data
% structures, the way that its procedures and modules interact etc.
\input{spec/professional_considerations}
